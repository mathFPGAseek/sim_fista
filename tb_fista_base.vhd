--------------------------------------------------------------------------------
-- (c) Copyright 2010 - 2013 Xilinx, Inc. All rights reserved.
--
-- This file contains confidential and proprietary information
-- of Xilinx, Inc. and is protected under U.S. and
-- international copyright and other intellectual property
-- laws.
--
-- DISCLAIMER
-- This disclaimer is not a license and does not grant any
-- rights to the materials distributed herewith. Except as
-- otherwise provided in a valid license issued to you by
-- Xilinx, and to the maximum extent permitted by applicable
-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
-- (2) Xilinx shall not be liable (whether in contract or tort,
-- including negligence, or under any other theory of
-- liability) for any loss or damage of any kind or nature
-- related to, arising under or in connection with these
-- materials, including for any direct, or any indirect,
-- special, incidental, or consequential loss or damage
-- (including loss of data, profits, goodwill, or any type of
-- loss or damage suffered as a result of any action brought
-- by a third party) even if such damage or loss was
-- reasonably foreseeable or Xilinx had been advised of the
-- possibility of the same.
--
-- CRITICAL APPLICATIONS
-- Xilinx products are not designed or intended to be fail-
-- safe, or for use in any application requiring fail-safe
-- performance, such as life-support or safety devices or
-- systems, Class III medical devices, nuclear facilities,
-- applications related to the deployment of airbags, or any
-- other applications that could lead to death, personal
-- injury, or severe property or environmental damage
-- (individually and collectively, "Critical
-- Applications"). Customer assumes the sole risk and
-- liability of any use of Xilinx products in Critical
-- Applications, subject only to applicable laws and
-- regulations governing limitations on product liability.
--
-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
-- PART OF THIS FILE AT ALL TIMES.
--------------------------------------------------------------------------------
-- Description:
-- This is an example testbench for the Fast Fourier Transform IP core.
-- The testbench has been generated by Vivado to accompany the IP core
-- instance you have generated.
--
-- This testbench is for demonstration purposes only.  See note below for
-- instructions on how to use it with your core.
--
-- See the Fast Fourier Transform product guide for further information
-- about this core.
--
--------------------------------------------------------------------------------
-- Using this testbench
--
-- This testbench instantiates your generated Fast Fourier Transform core
-- instance named "xfft_0".
--
-- Use Vivado's Run Simulation flow to run this testbench.  See the Vivado
-- documentation for details.
--------------------------------------------------------------------------------
-- engr: rbd
-- date: 11/8/22
-- descr: We start with the baseline demo tb and build our test env from here for
-- simulating the FPGA FISTA ACCEL. Note, that the testben ch code will later be
-- intgegrated into a controller, but for now we will start simple and just add up 
-- some more testbench constructs or modules( synthesizable) that will later becoime
-- our design 

library ieee;
--library work;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.math_real.all;
use std.textio.all;
-- added when reads not working
use ieee.std_logic_textio.all;

entity tb_xfft_0 is
end tb_xfft_0;

architecture tb of tb_xfft_0 is

  -----------------------------------------------------------------------
  -- Timing constants
  -----------------------------------------------------------------------
  constant CLOCK_PERIOD : time := 100 ns;
  constant T_HOLD       : time := 10 ns;
  constant T_STROBE     : time := CLOCK_PERIOD - (1 ns);
  
  -----------------------------------------------------------------------
  -- Constants, types and functions to create input data
  -----------------------------------------------------------------------

  constant IP_WIDTH    : integer := 34;
  constant MAX_SAMPLES : integer := 2**8;  -- maximum number of samples in a frame
  type T_IP_SAMPLE is record
    re : std_logic_vector(IP_WIDTH-1 downto 0);
    im : std_logic_vector(IP_WIDTH-1 downto 0);
  end record;
  type T_IP_TABLE is array (0 to MAX_SAMPLES-1) of T_IP_SAMPLE;
  
  -- memory type
  constant MEM_WIDTH   : integer := IP_WIDTH*2 -1;
  type MEM_ARRAY is array(0 to  MAX_SAMPLES-1,0 to MAX_SAMPLES-1) of std_logic_vector(MEM_WIDTH downto  0);  

  -- Zeroed input data table, for reset and initialization
  constant IP_TABLE_CLEAR : T_IP_TABLE := (others => (re => (others => '0'),
                                                      im => (others => '0')));
                                                     	
  -----------------------------------------------------------------------
  -- Read/write File Type and constants
  -----------------------------------------------------------------------                                                    	
  constant INPUT_BUFFER_SIZE : integer := 65537; -- arbitrary
  type image_data_word is array (INPUT_BUFFER_SIZE downto 0) of std_logic_vector(33 downto 0);
  file read_file : text;
  file read_imag_a_2d_forward_file : text;
  file read_real_a_2d_forward_file : text;
  file read_imag_V_hadmard_A_forward_file : text;
  file read_real_V_hadmard_A_forward_file : text;
  file read_imag_H_hadmard_A_forward_file : text;
  file read_real_H_hadmard_A_forward_file : text;
  file write_file : text;
  type result_type is ( '0', '1');
  signal write_line_done : result_type;
  signal write_fft_1d_done : result_type;
  signal write_fft_1d_seq_done : result_type;
  signal write_fft_1d_raw_done : result_type;
  
  signal write_fft_2d_raw_done : result_type;

  -----------------------------------------------------------------------
  -- DUT  FFT signals
  -----------------------------------------------------------------------
 
  -- General signals
  signal aclk                        : std_logic := '0';  -- the master clock
  signal aresetn                     : std_logic := '1';  -- synchronous active low reset

  -- Config slave channel signals
  signal s_axis_config_tvalid        : std_logic := '0';  -- payload is valid
  signal s_axis_config_tready        : std_logic := '1';  -- slave is ready
  signal s_axis_config_tdata         : std_logic_vector(15 downto 0) := (others => '0');  -- data payload

  -- Data slave channel signals
  signal s_axis_data_tvalid          : std_logic := '0';  -- payload is valid
  signal s_axis_data_tready          : std_logic := '1';  -- slave is ready
  signal s_axis_data_tdata           : std_logic_vector(79 downto 0) := (others => '0');  -- data payload
  signal s_axis_data_tlast           : std_logic := '0';  -- indicates end of packet

  -- Data master channel signals
  signal m_axis_data_tvalid          : std_logic := '0';  -- payload is valid
  signal m_axis_data_tready          : std_logic := '1';  -- slave is ready
  signal m_axis_data_tdata           : std_logic_vector(79 downto 0) := (others => '0');  -- data payload
  signal m_axis_data_tlast           : std_logic := '0';  -- indicates end of packet

  -- Event signals
  signal event_frame_started         : std_logic := '0';
  signal event_tlast_unexpected      : std_logic := '0';
  signal event_tlast_missing         : std_logic := '0';
  signal event_status_channel_halt   : std_logic := '0';
  signal event_data_in_channel_halt  : std_logic := '0';
  signal event_data_out_channel_halt : std_logic := '0';
  

  -----------------------------------------------------------------------
  -- Aliases for AXI channel TDATA and TUSER fields
  -- These are a convenience for viewing data in a simulator waveform viewer.
  -- If using ModelSim or Questa, add "-voptargs=+acc=n" to the vsim command
  -- to prevent the simulator optimizing away these signals.
  -----------------------------------------------------------------------

  -- Config slave channel alias signals
  signal s_axis_config_tdata_fwd_inv      : std_logic                    := '0';              -- forward or inverse
  signal s_axis_config_tdata_scale_sch    : std_logic_vector(7 downto 0) := (others => '0');  -- scaling schedule

  -- Data slave channel alias signals
  signal s_axis_data_tdata_re             : std_logic_vector(33 downto 0) := (others => '0');  -- real data
  signal s_axis_data_tdata_im             : std_logic_vector(33 downto 0) := (others => '0');  -- imaginary data

  -- Data master channel alias signals
  signal m_axis_data_tdata_re             : std_logic_vector(33 downto 0) := (others => '0');  -- real data
  signal m_axis_data_tdata_im             : std_logic_vector(33 downto 0) := (others => '0');  -- imaginary data
  
  -----------------------------------------------------------------------
  -- DUT  Hadmard signals
  -----------------------------------------------------------------------
    
  signal   s_axis_v_hadmard_tvalid   : std_logic;
  signal   s_axis_v_hadmard_tdata    : std_logic_vector(79 downto 0);
  signal   s_axis_h_hadmard_tvalid   : std_logic;
  signal   s_axis_h_hadmard_tdata    : std_logic_vector(79 downto 0);
  signal   m_axis_dout_tvalid        : std_logic;
  signal   m_axis_dout_tdata         : std_logic_vector(79 downto 0);


  -- signal  to help trasfer fr file to input vectors for fft
   signal fft_real_input_data : image_data_word;
   signal transfer_line  :  T_IP_TABLE;
   signal index_start : integer := 0;
   
   signal fft_real_A_forward_2d_input_data : image_data_word;
   signal fft_imag_A_forward_2d_input_data : image_data_word;
   
   signal hadmard_A_forward_imag_V_input_data : image_data_word;
   signal hadmard_A_forward_real_V_input_data : image_data_word;
   --signal V_hadmard_A_forward_2d_input_data : image_data_word;
   signal hadmard_A_forward_imag_H_input_data : image_data_word;
   signal hadmard_A_forward_real_H_input_data : image_data_word;
   
   
   -- shared signals for memory
   signal wr_2_mem : std_logic;
   signal lst_wr_2_mem : std_logic;
   signal wr_2_mem_r : std_logic;
   signal wr_2_mem_rr : std_logic;
   signal wr_2_mem_rrr: std_logic;
   signal lst_wr_2_mem_r : std_logic;
   signal lst_wr_2_mem_rr : std_logic;
   signal lst_wr_2_mem_rrr : std_logic;
   signal data_in_wr_2_mem: std_logic_vector(67 downto 0); -- don't care?
   signal line_wr_2_mem : integer := 0;
   	
   
   -- Specific memories
   signal fft_mem : MEM_ARRAY;
   signal op_sample_wr_2_mem : integer := 0;
   signal address_int   : integer := 0;
   
   signal fft_raw_mem : MEM_ARRAY;
   signal op_sample_wr_2_raw_mem : integer := 0;
   signal address_raw_int   : integer := 0;
   
   --constant and types
   constant LINE_119 : integer := 119;
   type bit_addr is array ( 0 to MAX_SAMPLES-1) of integer;
   signal rev_addr : bit_addr := 
     (0 ,128, 64, 192,	32,	160,	96,	224,	16,	144,	80,	208,	48,	176,	112,	240,	8,	136,	72,	200,	40,	168,	104,	232,	24,	152,	88,	216,	56,	184,	120,	248,
      4	,132, 68, 196,	36,	164,	100,228,	20,	148,	84,	212,	52,	180,	116,	244,	12,	140,	76,	204,	44,	172,	108,	236,	28,	156,	92,	220,	60,	188,	124,	252,
      2	,130, 66, 194,	34,	162,	98,	226,	18,	146,	82,	210,	50,	178,	114,	242,	10,	138,	74,	202,	42,	170,	106,	234,	26,	154,	90,	218,	58,	186,	122,	250,
      6	,134, 70, 198,	38,	166,	102,230,	22,	150,	86,	214,	54,	182,	118,	246,	14,	142,	78,	206,	46,	174,	110,	238,	30,	158,	94,	222,	62,	190,	126,	254,
      1	,129, 65, 193,	33,	161,	97,	225,	17,	145,	81,	209,	49,	177,	113,	241,	9,	137,	73,	201,	41,	169,	105,	233,	25,	153,	89,	217,	57,	185,	121,	249,
      5 ,133, 69, 197,	37,	165,	101,229,	21,	149,	85,	213,	53,	181,	117,	245,	13,	141,	77,	205,	45,	173,	109,	237,	29,	157,	93,	221,	61,	189,	125,	253,
      3	,131, 67, 195,	35,	163,	99,	227,	19,	147,	83,	211,	51,	179,	115,	243,	11,	139,	75,	203,	43,	171,	107,	235,	27,	155,	91,	219,	59,	187,	123,	251,
      7	,135, 71, 199,	39,	167,	103,231,	23,	151,	87,	215,	55,	183,	119,	247,	15,	143,	79,	207,	47,	175,	111,	239,	31,	159,	95,	223,	63,	191,	127,	255);
   signal fft_bin_center_addr : bit_addr :=
     (128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,
      160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191,
      192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223,
      224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 222, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255,
        0,   1,   2,  3,    4,   5,   6,   7,   8,   9,  10,  11,  12,  13,  14,  15,  16,  17,  18,  19,  20,  21,  22,  23,  24,  25,  26,  27,  28,  29,  30,  31,
       32,  33,  34, 35,   36,  37,  38,  39,  40,  41,  42,  43,  44,  45,  46,  47,  48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  58,  59,  60,  61,  62,  63,
       64,  65, 66,  67,   68,  69,  70,  71,  72,  73,  74,  75,  76,  77,  78,  79,  80,  81,  82,  83,  84,  85,  86,  87,  88,  89,  90,  91,  92,  93,  94,  95,
       96,  97, 98,  99,  100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127 );
   signal fft_bin_seq_addr : bit_addr :=
    (   0,   1,   2,  3,    4,   5,   6,   7,   8,   9,  10,  11,  12,  13,  14,  15,  16,  17,  18,  19,  20,  21,  22,  23,  24,  25,  26,  27,  28,  29,  30,  31,
       32,  33,  34, 35,   36,  37,  38,  39,  40,  41,  42,  43,  44,  45,  46,  47,  48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  58,  59,  60,  61,  62,  63,
       64,  65, 66,  67,   68,  69,  70,  71,  72,  73,  74,  75,  76,  77,  78,  79,  80,  81,  82,  83,  84,  85,  86,  87,  88,  89,  90,  91,  92,  93,  94,  95,
       96,  97, 98,  99,  100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127,
      128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,
      160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191,
      192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223,
      224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 222, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255 );

    -------------------------------------------------
	-- DEBUG :Write to a file for debugging
	-------------------------------------------------
	impure function writeToFileDebugTransferLine(  signal transfer_line  : in T_IP_TABLE) return result_type is
	   variable result         : result_type; 
	   variable mem_line_var   : line;
	   variable done           : integer;
	   variable data_write_var : bit_vector(67 downto 0);
	   variable sample_data    : std_logic_vector(67 downto 0);
	   begin
	     file_open(write_file,"transfer_line_vectors.txt",write_mode);
	     report" File Opened for writing ";
	          for i in  0 to MAX_SAMPLES-1 loop
	                  sample_data(33 downto 0)  := transfer_line(i).re;                  -- real data
                      sample_data(67 downto 34) := transfer_line(i).im;                  -- imaginary data
                      data_write_var := to_bitvector(sample_data);
	                  write(mem_line_var ,data_write_var);
	                  writeline(write_file,mem_line_var);
	                  report" Start writing to file ";
	          end loop;
	          done := 1;
	      file_close(write_file);
	      report" Done writing to file ";	  
  	      return result;  	       
     end function  writeToFileDebugTransferLine;
  -------------------------------------------------
	-- Write to a file the mem contents to check
	-------------------------------------------------
	impure function writeToFileMemRawContents(  signal fft_mem   : in MEM_ARRAY;
		                                       signal fft_bin_center_addr : in bit_addr) return result_type is
	   variable result       : result_type;    
	   variable mem_line_var : line;
	   variable done         : integer;
	   variable k            : integer;
	   variable fft_spec     : MEM_ARRAY;
	   variable data_write_var : bit_vector(67 downto 0);
	   begin
	   	 	for i in  0 to MAX_SAMPLES-1 loop
	         for j in 0 to MAX_SAMPLES-1 loop
	            k := fft_bin_center_addr(j);
	            fft_spec(i,k) := (fft_mem(i,j));
	         end loop;
	      end loop;
	     file_open(write_file,"fft_1d_mem_raw_vectors.txt",write_mode);
	     report" File Opened for writing ";
	          for i in  0 to MAX_SAMPLES-1 loop
	              for j in 0 to MAX_SAMPLES-1 loop
	                  data_write_var := to_bitvector(fft_spec(i,j));
	                  write(mem_line_var ,data_write_var);
	                  writeline(write_file,mem_line_var);                  
	                  --report" Start writing to file ";
	              end loop;
	          end loop;
	      done := 1;
	      file_close(write_file);
	      report" Done writing to file ";	  
  	    return result;  	       
     end function  writeToFileMemRawContents;
     
  	impure function writeToFileMemRawAForward2DContents(  signal fft_mem   : in MEM_ARRAY;
		                                       signal fft_bin_center_addr : in bit_addr) return result_type is
	   variable result       : result_type;    
	   variable mem_line_var : line;
	   variable done         : integer;
	   variable k            : integer;
	   variable fft_spec     : MEM_ARRAY;
	   variable data_write_var : bit_vector(67 downto 0);
	   begin
	   	 	for i in  0 to MAX_SAMPLES-1 loop
	         for j in 0 to MAX_SAMPLES-1 loop
	            k := fft_bin_center_addr(j);
	            fft_spec(i,k) := (fft_mem(i,j));
	         end loop;
	      end loop;
	     file_open(write_file,"fft_A_forward_2d_mem_raw_vectors.txt",write_mode);
	     report" File Opened for writing ";
	          for j in  0 to MAX_SAMPLES-1 loop
	              for i in 0 to MAX_SAMPLES-1 loop
	                  data_write_var := to_bitvector(fft_spec(i,j));
	                  write(mem_line_var ,data_write_var);
	                  writeline(write_file,mem_line_var);                  
	                  --report" Start writing to file ";
	              end loop;
	          end loop;
	      done := 1;
	      file_close(write_file);
	      report" Done writing to file ";	  
  	    return result;  	       
     end function  writeToFileMemRawAForward2DContents;
     
  -- Function that will be a point source  
  function read_input_stim_fr_file(signal index_start    : in integer; 
  	                               signal fft_real_input_data : in image_data_word) return T_IP_TABLE is
    variable result : T_IP_TABLE;	
    variable end_index : integer;
    variable K : integer := 0;
    variable i : integer;
  	constant MAX_SAMPLES : integer := 256;
  	begin
  	  --report " start reading input file";
  	  end_index := index_start + MAX_SAMPLES - 1;
  	  for i in index_start to end_index loop
  	    result(K).re := fft_real_input_data(i);
  	    result(K).im := (others=> '0');
  	    K := K + 1;	  	  
  	  end loop;
  	  return result;                                              	     
  end function  read_input_stim_fr_file;
  
  function read_input_stim_re_and_imag_fr_file(signal index_start    : in integer; 
  	                               signal fft_real_input_data : in image_data_word;
  	                               signal fft_imag_input_data : in image_data_word) return T_IP_TABLE is
    variable result : T_IP_TABLE;	
    variable end_index : integer;
    variable K : integer := 0;
    variable i : integer;
  	constant MAX_SAMPLES : integer := 256;
  	begin
  	  --report " start reading input file";
  	  end_index := index_start + MAX_SAMPLES - 1;
  	  for i in index_start to end_index loop
  	    result(K).re := fft_real_input_data(i);
  	    result(K).im := fft_imag_input_data(i);
  	    K := K + 1;	  	  
  	  end loop;
  	  return result;                                              	     
  end function  read_input_stim_re_and_imag_fr_file;
  
  function read_input_stim_re_and_imag_H_A_fr_file(signal index_start    : in integer; 
  	                               signal hadmard_A_forward_real_H_input_data : in image_data_word;
  	                               signal hadmard_A_forward_imag_H_input_data : in image_data_word) return T_IP_TABLE is
    variable result : T_IP_TABLE;	
    variable end_index : integer;
    variable K : integer := 0;
    variable i : integer;
  	constant MAX_SAMPLES : integer := 256;
  	begin
  	  ---report " start reading input file";
  	  end_index := index_start + MAX_SAMPLES - 1;
  	  for i in index_start to end_index loop
  	    result(K).re := hadmard_A_forward_real_H_input_data(i);
  	    result(K).im := hadmard_A_forward_imag_H_input_data(i);
  	    K := K + 1;	  	  
  	  end loop;
  	  return result;                                              	     
  end function  read_input_stim_re_and_imag_H_A_fr_file;
  
  
  
  
  -- Function to generate input data table
  -- Data is a complex sinusoid exp(-jwt) with a frequency 2.6 times the frame size
  -- added to another with a lower magnitude and a higher frequency
  function create_ip_table return T_IP_TABLE is
    variable result : T_IP_TABLE;
    variable theta  : real;
    variable theta2 : real;
    variable re_real : real;
    variable im_real : real;
    variable re_int : integer;
    variable im_int : integer;
    constant DATA_WIDTH : integer := 30;
  begin
    for i in 0 to MAX_SAMPLES-1 loop
      theta   := real(i) / real(MAX_SAMPLES) * 2.6 * 2.0 * MATH_PI;
      re_real := cos(-theta);
      im_real := sin(-theta);
      theta2  := real(i) / real(MAX_SAMPLES) * 23.2 * 2.0 * MATH_PI;
      re_real := re_real + (cos(-theta2) / 4.0);
      im_real := im_real + (sin(-theta2) / 4.0);
      re_int  := integer(round(re_real * real(2**(DATA_WIDTH))));
      im_int  := integer(round(im_real * real(2**(DATA_WIDTH))));
      result(i).re := std_logic_vector(to_signed(re_int, IP_WIDTH));
      result(i).im := std_logic_vector(to_signed(im_int, IP_WIDTH));
    end loop;
    return result;
  end function create_ip_table;

  -- Call the function to create the input data
  constant IP_DATA : T_IP_TABLE := create_ip_table;

  -----------------------------------------------------------------------
  -- Testbench signals
  -----------------------------------------------------------------------

  -- Communication between processes regarding DUT configuration
  type T_DO_CONFIG is (NONE, IMMEDIATE, AFTER_START, DONE);
  shared variable do_config : T_DO_CONFIG := NONE;  -- instruction for driving config slave channel
  type T_CFG_FWD_INV is (FWD, INV);
  signal cfg_fwd_inv : T_CFG_FWD_INV := FWD;
  type T_CFG_SCALE_SCH is (ZERO, DEFAULT);
  signal cfg_scale_sch : T_CFG_SCALE_SCH := DEFAULT;

  -- Recording output data, for reuse as input data
  signal op_sample       : integer    := 0;    -- output sample number
  signal op_sample_first : std_logic  := '1';  -- indicates first output sample of a frame
  signal ip_frame        : integer    := 0;    -- input / configuration frame number
  signal op_data         : T_IP_TABLE := IP_TABLE_CLEAR;  -- recorded output data
  signal op_frame        : integer    := 0;    -- output frame number (incremented at end of frame output)


begin

  -----------------------------------------------------------------------
  -- Instantiate the DUT
  -----------------------------------------------------------------------
  
  -- Add a normalization block ??

  dut_fft : entity work.xfft_0
    port map (
      aclk                        => aclk,
      aresetn                     => aresetn,
      s_axis_config_tvalid        => s_axis_config_tvalid,
      s_axis_config_tready        => s_axis_config_tready,
      s_axis_config_tdata         => s_axis_config_tdata,
      s_axis_data_tvalid          => s_axis_data_tvalid,
      s_axis_data_tready          => s_axis_data_tready,
      s_axis_data_tdata           => s_axis_data_tdata,
      s_axis_data_tlast           => s_axis_data_tlast,
      m_axis_data_tvalid          => m_axis_data_tvalid,
      m_axis_data_tready          => m_axis_data_tready,
      m_axis_data_tdata           => m_axis_data_tdata,
      m_axis_data_tlast           => m_axis_data_tlast,
      event_frame_started         => event_frame_started,
      event_tlast_unexpected      => event_tlast_unexpected,
      event_tlast_missing         => event_tlast_missing,
      event_status_channel_halt   => event_status_channel_halt,
      event_data_in_channel_halt  => event_data_in_channel_halt,
      event_data_out_channel_halt => event_data_out_channel_halt
      );
      
  dut_hadmard_mult_0 : entity work.cmpy_0 
  port map( 
    aclk                          => aclk,                     --in STD_LOGIC;
    aresetn                       => aresetn,                  --in STD_LOGIC; 
    s_axis_a_tvalid               => s_axis_v_hadmard_tvalid,  --in STD_LOGIC;
    s_axis_a_tdata                => s_axis_v_hadmard_tdata,   --in STD_LOGIC_VECTOR ( 79 downto 0 );
    s_axis_b_tvalid               => s_axis_h_hadmard_tvalid,  --in STD_LOGIC;
    s_axis_b_tdata                => s_axis_h_hadmard_tdata,   --in STD_LOGIC_VECTOR ( 79 downto 0 );
    m_axis_dout_tvalid            => m_axis_dout_tvalid,       --out STD_LOGIC;
    m_axis_dout_tdata             => m_axis_dout_tdata         --out STD_LOGIC_VECTOR ( 79 downto 0 )
  );


  -----------------------------------------------------------------------
  -- Generate clock
  -----------------------------------------------------------------------

  clock_gen : process
  begin
    aclk <= '0';
    wait for CLOCK_PERIOD;
    loop
      aclk <= '0';
      wait for CLOCK_PERIOD/2;
      aclk <= '1';
      wait for CLOCK_PERIOD/2;
    end loop;
  end process clock_gen;
  
  
    -------------------------------------------------
	-- Read From file for psf 
	-------------------------------------------------
	readInputStim : process
		variable inputLine : line;
		variable data_bit_sample : bit_vector(33 downto 0);
		variable data_slv_sample : std_logic_vector(33 downto 0);
		variable I : integer := 0;
		constant  MAX_NUM_SAMPLE_TO_READ : integer := 65537; 
	begin
		report "Entered Read input process: " severity note;
		file_open(read_file,"real_psf_vectors.txt",read_mode);
		command_loop : while not endfile(read_file) and I < MAX_NUM_SAMPLE_TO_READ  loop
			readline(read_file,inputLine);
			read(inputLine,data_bit_sample);
			data_slv_sample := to_stdlogicvector(data_bit_sample);
			fft_real_input_data(I) <= data_slv_sample;
			I := I + 1;
		end loop;
		--write(OUTPUT, "This is the time: " & to_string(now) & LF) ;
		wait;
	end process ; -- readInputStim
	
   readInputAMatrix2DRealStim : process
		variable inputLine : line;
		variable data_bit_sample : bit_vector(33 downto 0);
		variable data_slv_sample : std_logic_vector(33 downto 0);
		variable I : integer := 0;
		constant  MAX_NUM_SAMPLE_TO_READ : integer := 65537; 
	begin
		report "Entered Read input process: " severity note;
		file_open(read_real_a_2d_forward_file,"real_A_forward_2d_psf_vectors.txt",read_mode);
		command_loop : while not endfile(read_real_a_2d_forward_file) and I < MAX_NUM_SAMPLE_TO_READ  loop
			readline(read_real_a_2d_forward_file,inputLine);
			read(inputLine,data_bit_sample);
			data_slv_sample := to_stdlogicvector(data_bit_sample);
			fft_real_A_forward_2d_input_data(I) <= data_slv_sample;
			I := I + 1;
		end loop;
		--write(OUTPUT, "This is the time: " & to_string(now) & LF) ;
		wait;
	end process ; -- readInputStim
	
    readInputAMatrix2DImagStim : process
		variable inputLine : line;
		variable data_bit_sample : bit_vector(33 downto 0);
		variable data_slv_sample : std_logic_vector(33 downto 0);
		variable I : integer := 0;
		constant  MAX_NUM_SAMPLE_TO_READ : integer := 65537; 
	begin
		report "Entered Read input process: " severity note;
		file_open(read_imag_a_2d_forward_file,"imag_A_forward_2d_psf_vectors.txt",read_mode);
		command_loop : while not endfile(read_imag_a_2d_forward_file) and I < MAX_NUM_SAMPLE_TO_READ  loop
			readline(read_imag_a_2d_forward_file,inputLine);
			read(inputLine,data_bit_sample);
			data_slv_sample := to_stdlogicvector(data_bit_sample);
			fft_imag_A_forward_2d_input_data(I) <= data_slv_sample;
			I := I + 1;
		end loop;
		--write(OUTPUT, "This is the time: " & to_string(now) & LF) ;
		wait;
	end process ; -- readInputStim
	
   readInputImagHHadmardStim : process
		variable inputLine : line;
		variable data_bit_sample : bit_vector(33 downto 0);
		variable data_slv_sample : std_logic_vector(33 downto 0);
		variable I : integer := 0;
		constant  MAX_NUM_SAMPLE_TO_READ : integer := 65537; 
	begin
		report "Entered Read input process: " severity note;
		file_open(read_imag_H_hadmard_A_forward_file,"2d_imag_H_psf_vectors.txt",read_mode);
		command_loop : while not endfile(read_imag_H_hadmard_A_forward_file) and I < MAX_NUM_SAMPLE_TO_READ  loop
			readline(read_imag_H_hadmard_A_forward_file,inputLine);
			read(inputLine,data_bit_sample);
			data_slv_sample := to_stdlogicvector(data_bit_sample);
			hadmard_A_forward_imag_H_input_data(I) <= data_slv_sample;
			I := I + 1;
		end loop;
		--write(OUTPUT, "This is the time: " & to_string(now) & LF) ;
		wait;
	end process ; -- readInputStim.
	
    readInputRealHHadmardStim : process
		variable inputLine : line;
		variable data_bit_sample : bit_vector(33 downto 0);
		variable data_slv_sample : std_logic_vector(33 downto 0);
		variable I : integer := 0;
		constant  MAX_NUM_SAMPLE_TO_READ : integer := 65537; 
	begin
		report "Entered Read input process: " severity note;
		file_open(read_real_H_hadmard_A_forward_file,"2d_real_H_psf_vectors.txt",read_mode);
		command_loop : while not endfile(read_real_H_hadmard_A_forward_file) and I < MAX_NUM_SAMPLE_TO_READ  loop
			readline(read_real_H_hadmard_A_forward_file,inputLine);
			read(inputLine,data_bit_sample);
			data_slv_sample := to_stdlogicvector(data_bit_sample);
			hadmard_A_forward_real_H_input_data(I) <= data_slv_sample;
			I := I + 1;
		end loop;
		--write(OUTPUT, "This is the time: " & to_string(now) & LF) ;
		wait;
	end process ; -- readInputStim.
	
    readInputImagVHadmardStim : process
		variable inputLine : line;
		variable data_bit_sample : bit_vector(33 downto 0);
		variable data_slv_sample : std_logic_vector(33 downto 0);
		variable I : integer := 0;
		constant  MAX_NUM_SAMPLE_TO_READ : integer := 65537; 
	begin
		report "Entered Read input process: " severity note;
		file_open(read_imag_V_hadmard_A_forward_file,"imag_A_forward_V_hadmard_vector.txt",read_mode);
		command_loop : while not endfile(read_imag_V_hadmard_A_forward_file) and I < MAX_NUM_SAMPLE_TO_READ  loop
			readline(read_imag_V_hadmard_A_forward_file,inputLine);
			read(inputLine,data_bit_sample);
			data_slv_sample := to_stdlogicvector(data_bit_sample);
			hadmard_A_forward_imag_V_input_data(I) <= data_slv_sample;
			I := I + 1;
		end loop;
		--write(OUTPUT, "This is the time: " & to_string(now) & LF) ;
		wait;
	end process ; -- readInputStim.

     
     readInputRealVHadmardStim : process
		variable inputLine : line;
		variable data_bit_sample : bit_vector(33 downto 0);
		variable data_slv_sample : std_logic_vector(33 downto 0);
		variable I : integer := 0;
		constant  MAX_NUM_SAMPLE_TO_READ : integer := 65537; 
	begin
		report "Entered Read input process: " severity note;
		file_open(read_real_V_hadmard_A_forward_file,"real_A_forward_V_hadmard_vector.txt",read_mode); -- renamed from matlab
		command_loop : while not endfile(read_real_V_hadmard_A_forward_file) and I < MAX_NUM_SAMPLE_TO_READ  loop
			readline(read_real_V_hadmard_A_forward_file,inputLine);
			read(inputLine,data_bit_sample);
			data_slv_sample := to_stdlogicvector(data_bit_sample);
			hadmard_A_forward_real_V_input_data(I) <= data_slv_sample;
			I := I + 1;
		end loop;
		--write(OUTPUT, "This is the time: " & to_string(now) & LF) ;
		wait;
	end process ; -- readInputStim.
  -----------------------------------------------------------------------
  -- Generate data slave channel inputs
  -----------------------------------------------------------------------

  data_stimuli : process

    -- Variables for random number generation
    variable seed1, seed2 : positive;
    variable rand         : real;

    -- Procedure to drive an input sample with specific data
    -- data is the data value to drive on the tdata signal
    -- last is the bit value to drive on the tlast signal
    -- valid_mode defines how to drive TVALID: 0 = TVALID always high, 1 = TVALID low occasionally
    procedure drive_sample ( data       : std_logic_vector(79 downto 0);
                             last       : std_logic;
                             valid_mode : integer := 0 ) is
    begin
      s_axis_data_tdata  <= data;
      s_axis_data_tlast  <= last;

      if valid_mode = 1 then
        uniform(seed1, seed2, rand);  -- generate random number
        if rand < 0.25 then
          s_axis_data_tvalid <= '0';
          uniform(seed1, seed2, rand);  -- generate another random number
          wait for CLOCK_PERIOD * integer(round(rand * 4.0));  -- hold TVALID low for up to 4 cycles
          s_axis_data_tvalid <= '1';  -- now assert TVALID
        else
          s_axis_data_tvalid <= '1';
        end if;
      else
        s_axis_data_tvalid <= '1';
      end if;
      loop
        wait until rising_edge(aclk);
        exit when s_axis_data_tready = '1';
      end loop;
      wait for T_HOLD;
      s_axis_data_tvalid <= '0';
    end procedure drive_sample;

    -- Procedure to drive an input frame with a table of data
    -- data is the data table containing input data
    -- valid_mode defines how to drive TVALID: 0 = TVALID always high, 1 = TVALID low occasionally
    procedure drive_frame ( data         : T_IP_TABLE;
                            valid_mode   : integer := 0 ) is
      variable samples : integer;
      variable index   : integer;
      variable sample_data : std_logic_vector(79 downto 0);
      variable sample_last : std_logic;
    begin
      samples := data'length;
      index  := 0;
      while index < data'length loop
        -- Look up sample data in data table, construct TDATA value
        sample_data(33 downto 0)  := data(index).re;                  -- real data
        sample_data(39 downto 34) := (others => data(index).re(33));  -- sign-extend
        sample_data(73 downto 40) := data(index).im;                  -- imaginary data
        sample_data(79 downto 74) := (others => data(index).im(33));  -- sign-extend
        -- Construct TLAST's value
        index := index + 1;
        if index >= data'length then
          sample_last := '1';
        else
          sample_last := '0';
        end if;
        -- Drive the sample
        drive_sample(sample_data, sample_last, valid_mode);
      end loop;
    end procedure drive_frame;

    variable op_data_saved : T_IP_TABLE;  -- to save a copy of recorded output data


  begin
    for i in 0 to MAX_SAMPLES-1 loop -- Row proessing A matrix 
        wr_2_mem <= '0';
        lst_wr_2_mem <= '0';
        -- Drive inputs T_HOLD time after rising edge of clock
        wait until rising_edge(aclk) and aresetn = '1';
        wait for T_HOLD;

        -- Drive a frame of input data
        ip_frame <= 1;
       -- Need to read first N lines from input file array from file 
        transfer_line <= read_input_stim_fr_file(index_start => index_start, fft_real_input_data => fft_real_input_data);

        --drive_frame(IP_DATA);
        wait until rising_edge(aclk);
        wait for T_HOLD;
        drive_frame(transfer_line);

        -- Allow the result to emerge
        wait until m_axis_data_tlast = '1';
        wait until rising_edge(aclk);
        wait for T_HOLD;

        if ( i = 119) then
        	report " index i =" & integer'image(i);
        	report " index_start =" & integer'image(index_start);
        end if;
        	       
        -- write stored op_data into memory
        for k in 0 to MAX_SAMPLES-1 loop
          wait until rising_edge(aclk);
          wr_2_mem <= '1';
          --debug
          if ( k = 32) and (i = 119) then
          	report " inside for loop for writing to memory";
          end if;
  
        end loop;     
        wait until rising_edge(aclk);
        wr_2_mem <= '0';
       	lst_wr_2_mem <= '1';
       	wait until rising_edge(aclk);
        wr_2_mem <= '0';
        lst_wr_2_mem <= '0';
        wait until rising_edge(aclk);
        wait until rising_edge(aclk);
  
        -- incr line to write
        line_wr_2_mem <= line_wr_2_mem + 1;
        -- incr index_start
        index_start <= index_start + MAX_SAMPLES;
    end loop;

    -- report write to file
    report " start writing fft 1d file";
    
    --write to file the reordered sequence
    write_fft_1d_raw_done <= writeToFileMemRawContents(fft_raw_mem,fft_bin_seq_addr);
    
    -- completed 1-d fft
    report " completed 1-d fft";
    
    -- reinit
    line_wr_2_mem <= 0;
    index_start <= 0;
    uniform(seed1, seed2, rand);
    wait for CLOCK_PERIOD * integer(round(rand * 50.0));  -- wait 50 clock cycles
    
    index_start <= 0;
    
       for i in 0 to MAX_SAMPLES-1 loop -- Col  processing A matrix 
        wr_2_mem <= '0';
        lst_wr_2_mem <= '0';
        -- Drive inputs T_HOLD time after rising edge of clock
        wait until rising_edge(aclk) and aresetn = '1';
        wait for T_HOLD;

        -- Drive a frame of input data
        ip_frame <= 2;
       -- Need to read first N lines from input file array from file 
        transfer_line <= read_input_stim_re_and_imag_fr_file(index_start => index_start, fft_real_input_data => fft_real_A_forward_2d_input_data,
                                                             fft_imag_input_data => fft_imag_A_forward_2d_input_data );

        --drive_frame(IP_DATA);
        wait until rising_edge(aclk);
        wait for T_HOLD;
        drive_frame(transfer_line);

        -- Allow the result to emerge
        wait until m_axis_data_tlast = '1';
        wait until rising_edge(aclk);
        wait for T_HOLD;

        --if ( i = 119) then
        --	report " index i =" & integer'image(i);
        --	report " index_start =" & integer'image(index_start);
        --end if;
        	       
        -- write stored op_data into memory
        for k in 0 to MAX_SAMPLES-1 loop
          wait until rising_edge(aclk);
          wr_2_mem <= '1';
          --debug
          if ( k = 32) and (i = 119) then
          	report " inside for loop for writing to memory";
          end if;
  
        end loop;     
        wait until rising_edge(aclk);
        wr_2_mem <= '0';
       	lst_wr_2_mem <= '1';
       	wait until rising_edge(aclk);
        wr_2_mem <= '0';
        lst_wr_2_mem <= '0';
        wait until rising_edge(aclk);
        wait until rising_edge(aclk);
  
        -- incr line to write
        line_wr_2_mem <= line_wr_2_mem + 1;
        -- incr index_start
        index_start <= index_start + MAX_SAMPLES;
    end loop;

  
       -- report write to file
    report " start writing fft 2d file";
    
    --write to file the reordered sequence
    write_fft_2d_raw_done <= writeToFileMemRawAForward2DContents(fft_raw_mem,fft_bin_seq_addr);
    
    -- completed 1-d fft
    report " completed 2-d fft";
   
    -- reinit
    --line_wr_2_mem <= 0;
    index_start <= 0;
    uniform(seed1, seed2, rand);
    wait for CLOCK_PERIOD * integer(round(rand * 50.0));  -- wait 50 clock cycles
    
    index_start <= 0;
    
       for i in 0 to MAX_SAMPLES-1 loop -- Col  processing A matrix 
        --wr_2_mem <= '0';
        --lst_wr_2_mem <= '0';
        -- Drive inputs T_HOLD time after rising edge of clock
        wait until rising_edge(aclk) and aresetn = '1';
        wait for T_HOLD;

        -- Drive a frame of input data : This is H A Calculation
        ip_frame <= 3;
         
       -- Need to read first N lines from input file array from file 
        transfer_line <= read_input_stim_re_and_imag_H_A_fr_file(index_start => index_start, 
                         hadmard_A_forward_real_H_input_data => hadmard_A_forward_real_H_input_data,
                         hadmard_A_forward_imag_H_input_data => hadmard_A_forward_imag_H_input_data);

        
        --drive_frame(IP_DATA);
        wait until rising_edge(aclk);
        wait for T_HOLD;
        --drive_frame(transfer_line);
         index_start <= index_start + MAX_SAMPLES;

      end loop;
   ---- END of one A Frame
      report " Read Hadmard data for processing";
    wait;
    -- Keep stuff below for info
    -- Now perform an inverse transform on the result to get back to the original input
    -- Set up the configuration (config_stimuli process handles the config slave channel)
    ip_frame <= 2;
    cfg_fwd_inv <= INV;
    do_config := IMMEDIATE;
    while do_config /= DONE loop
      wait until rising_edge(aclk) and aresetn = '1';
    end loop;
    wait for T_HOLD;

    -- Configuration is done.  Set up another configuration to return to forward transforms,
    -- and make the configuration occur as soon as the next frame has begun
    ip_frame <= 3;
    cfg_fwd_inv <= FWD;
    do_config := AFTER_START;

    -- Now drive the input data, using the output data of the last frame
    drive_frame(op_data);
    wait until m_axis_data_tlast = '1';
    wait until rising_edge(aclk);
    wait for T_HOLD;

    -- The frame is complete, and the configuration to forward transforms has already been done,
    -- so drive the input data, using the output data of the last frame,
    -- which is the same as the original input (excepting scaling and finite precision effects).
    -- This time, deassert the data slave channel TVALID occasionally to illustrate AXI handshaking effects:
    -- as the core is configured to use Non Real Time throttle scheme, it will pause when TVALID is low.
    drive_frame(op_data, 1);

    -- During the output of this frame, deassert the data master channel TREADY occasionally:
    -- as the core is configured to use Non Real Time throttle scheme, it will pause when TREADY is low.
    wait until m_axis_data_tvalid = '1';
    wait until rising_edge(aclk);
    while m_axis_data_tlast /= '1' loop
      wait for T_HOLD;
      uniform(seed1, seed2, rand);  -- generate random number
      if rand < 0.25 then
        m_axis_data_tready <= '0';
      else
        m_axis_data_tready <= '1';
      end if;
      wait until rising_edge(aclk);
    end loop;
    wait for T_HOLD;
    m_axis_data_tready <= '1';
    wait for CLOCK_PERIOD;

    -- Demonstrate use of aresetn to reset the core: start another frame but reset the core before it completes
    ip_frame <= 4;
    drive_frame(IP_DATA);
    wait for CLOCK_PERIOD * 5;
    aresetn <= '0';  -- assert reset (active low)
    wait for CLOCK_PERIOD * 2;  -- hold reset active for 2 cycles, as stated in the FFT Datasheet
    aresetn <= '1';  -- deassert reset
    wait for CLOCK_PERIOD * 5;

    -- Now run 4 back-to-back transforms, as quickly as possible.
    -- First queue up 2 configurations: these will be applied successively over the next 2 transforms.
    -- 1st configuration
    ip_frame <= 4;
    cfg_fwd_inv <= FWD;  -- forward transform
    cfg_scale_sch <= DEFAULT;  -- default scaling schedule
    do_config := IMMEDIATE;
    while do_config /= DONE loop
      wait until rising_edge(aclk) and aresetn = '1';
    end loop;
    wait for T_HOLD;

    -- 2nd configuration: same as 1st, except:
    ip_frame <= 5;
    cfg_fwd_inv <= INV;  -- inverse transform
    cfg_scale_sch <= ZERO;  -- no scaling
    do_config := IMMEDIATE;
    while do_config /= DONE loop
      wait until rising_edge(aclk) and aresetn = '1';
    end loop;
    wait for T_HOLD;

    -- Drive the 1st data frame
    drive_frame(IP_DATA);

    -- Request a 3rd configuration, to be sent after 2nd data frame starts
    ip_frame <= 6;
    cfg_fwd_inv <= FWD;  -- forward transform
    cfg_scale_sch <= ZERO;  -- no scaling
    do_config := AFTER_START;

    -- Drive the 2nd data frame
    drive_frame(op_data_saved);

    -- Request a 4th configuration, to be sent after 3rd data frame starts: same as 3rd, except:
    ip_frame <= 7;
    cfg_fwd_inv <= INV;  -- inverse transform
    cfg_scale_sch <= DEFAULT;  -- default scaling schedule
    do_config := AFTER_START;

    -- Drive the 3rd data frame
    drive_frame(IP_DATA);

    -- Drive the 4th data frame
    drive_frame(op_data_saved);

    -- Wait until all the output data from all frames has been produced
    wait until op_frame = 7;
    wait for CLOCK_PERIOD * 10;

    -- End of test
    report "Not a real failure. Simulation finished successfully. Test completed successfully" severity failure;
    wait;

  end process data_stimuli;

  -----------------------------------------------------------------------
  -- Generate config slave channel inputs
  -----------------------------------------------------------------------

  config_stimuli : process
    variable scale_sch : std_logic_vector(7 downto 0);
  begin

    -- Drive a configuration when requested by data_stimuli process
    wait until rising_edge(aclk) and aresetn = '1';
    while do_config = NONE or do_config = DONE loop
      wait until rising_edge(aclk) and aresetn = '1';
    end loop;

    -- If the configuration is requested to occur after the next frame starts, wait for that event
    if do_config = AFTER_START then
      wait until event_frame_started = '1';
      wait until rising_edge(aclk) and aresetn = '1';
    end if;

    -- Drive inputs T_HOLD time after rising edge of clock
    wait for T_HOLD;

    -- Construct the config slave channel TDATA signal
    s_axis_config_tdata <= (others => '0');  -- clear unused bits
    -- Format the transform direction
    if cfg_fwd_inv = FWD then
      s_axis_config_tdata(0) <= '1';  -- forward
    elsif cfg_fwd_inv = INV then
      s_axis_config_tdata(0) <= '0';  -- inverse
    end if;
    -- Format the scaling schedule
    if cfg_scale_sch = ZERO then  -- no scaling
      scale_sch := (others => '0');
    elsif cfg_scale_sch = DEFAULT then  -- default scaling, for largest magnitude output with no overflow guaranteed
      scale_sch(1 downto 0) := "11";  -- largest scaling at first stage
      for s in 2 to 4 loop
        scale_sch(s*2-1 downto s*2-2) := "10";  -- less scaling at later stages
      end loop;
    end if;
    s_axis_config_tdata(8 downto 1) <= scale_sch;

    -- Drive the transaction on the config slave channel
    s_axis_config_tvalid <= '1';
    loop
      wait until rising_edge(aclk);
      exit when s_axis_config_tready = '1';
    end loop;
    wait for T_HOLD;
    s_axis_config_tvalid <= '0';

    -- Tell the data_stimuli process that the configuration has been done
    do_config := DONE;

  end process config_stimuli;
      -----------------------------------------------------------------------
  -- Store FFT outputs to memory; We are reading an array built by  process record_outputs
  -----------------------------------------------------------------------
  RamProcRawData : process(aclk)
  	
  begin
  	if rising_edge(aclk) then
  		if aresetn = '0' then
  			data_in_wr_2_mem <= (Others => '0'); -- don't care
  		elsif wr_2_mem_rrr = '1' then 		
  			fft_raw_mem(line_wr_2_mem,address_raw_int) <= op_data(address_raw_int).im & op_data(address_raw_int).re; 
  				  
  		end if; -- wr mem
    end if; --aclk
   end process RamProcRawData;
  -----------------------------------------------------------------------
  -- Calculate Adr to Store FFT outputs to memory; 
  -----------------------------------------------------------------------
  RamProcRawAdr : process(aclk)
  begin
  	if rising_edge(aclk) then
  		if aresetn = '0' then
  			op_sample_wr_2_raw_mem    <= 0;
  			address_raw_int           <= 0;
  			
  		elsif wr_2_mem_rr = '1' then 		
  			address_raw_int <= op_sample_wr_2_raw_mem;				
  			op_sample_wr_2_raw_mem <= op_sample_wr_2_raw_mem + 1;
  			
  		elsif lst_wr_2_mem_rr = '1' then 	
  			op_sample_wr_2_raw_mem <= 0;
 
  		end if; -- wr mem
    end if; --aclk
   end process RamProcRawAdr;
    -----------------------------------------------------------------------
  -- Store FFT outputs to memory; We are reading an array built by  process record_outputs
  -----------------------------------------------------------------------
  RamProcData : process(aclk)
  	
  begin
  	if rising_edge(aclk) then
  		if aresetn = '0' then
  			data_in_wr_2_mem <= (Others => '0');
  		elsif wr_2_mem_rrr = '1' then 		
  			--data_in_wr_2_mem <= op_data(address_int).im & op_data(address_int).re;   
  			--fft_mem(line_wr_2_mem,address_int) <= data_in_wr_2_mem;
  			fft_mem(line_wr_2_mem,address_int) <= op_data(address_int).im & op_data(address_int).re;
  			          		          --DEBUG
            if (line_wr_2_mem  = LINE_119)  then
  			  report " *******************";
         	  report " DEBUG/FFT_MEM";
         	  report " Line ="             & integer'image(line_wr_2_mem );
              report " Address int ="      & integer'image(address_int );
         	  report " fft real sample = " & integer'image(to_integer(unsigned(op_data(address_int).re)));
         	  report " fft imsg sample = " & integer'image(to_integer(unsigned(op_data(address_int).im)));
         	  report " *******************"; 
         	   
            end if; 

  		end if; -- wr mem
    end if; --aclk
   end process RamProcData;
  -----------------------------------------------------------------------
  -- Calculate Adr to Store FFT outputs to memory; 
  -----------------------------------------------------------------------
  RamProcAdr : process(aclk)
  begin
  	if rising_edge(aclk) then
  		if aresetn = '0' then
  			op_sample_wr_2_mem    <= 0;
  			address_int           <= 0;
  			
  		elsif wr_2_mem_rr = '1' then 		
  			address_int <= rev_addr(op_sample_wr_2_mem);				
  			op_sample_wr_2_mem <= op_sample_wr_2_mem + 1;
  			
  		elsif lst_wr_2_mem_rr = '1' then 	
  			op_sample_wr_2_mem <= 0;
 
  		end if; -- wr mem
    end if; --aclk
   end process RamProcAdr;
   
  -----------------------------------------------------------------------
  -- Ancillary delays 
  -----------------------------------------------------------------------			
  del_wr_registers : process(aclk)
  	begin
  		if aresetn = '0' then
  			wr_2_mem_r        <= '0';
  			wr_2_mem_rr       <= '0';
  			wr_2_mem_rrr      <= '0';
  			lst_wr_2_mem_r    <= '0';
  			lst_wr_2_mem_rr   <= '0';
  			lst_wr_2_mem_rrr  <= '0';
  	 
  	elsif( aclk'event and aclk = '1') then
  		  wr_2_mem_r       <= wr_2_mem;
  		  wr_2_mem_rr      <= wr_2_mem_r;
  		  wr_2_mem_rrr     <= wr_2_mem_rr;
  		  lst_wr_2_mem_r   <= lst_wr_2_mem;
  		  lst_wr_2_mem_rr  <= lst_wr_2_mem_r;
  		  lst_wr_2_mem_rrr  <= lst_wr_2_mem_rr;
  	
    end if;
  end process del_wr_registers;			

  -----------------------------------------------------------------------
  -- Record outputs, to use later as inputs for another frame
  -----------------------------------------------------------------------

  record_outputs : process (aclk)
    -- Function to digit-reverse an integer, to convert output to input ordering
    function digit_reverse_int ( fwd, width : integer ) return integer is
      variable rev     : integer;
      variable fwd_slv : std_logic_vector(width-1 downto 0);
      variable rev_slv : std_logic_vector(width-1 downto 0);
    begin
      fwd_slv := std_logic_vector(to_unsigned(fwd, width));
      for i in 0 to width/2-1 loop  -- reverse in digit groups (2 bits at a time)
        rev_slv(i*2+1 downto i*2) := fwd_slv(width-i*2-1 downto width-i*2-2);
      end loop;
      if width mod 2 = 1 then  -- width is odd: LSB moves to MSB
        rev_slv(width-1) := fwd_slv(0);
      end if;
      rev := to_integer(unsigned(rev_slv));
      return rev;
    end function digit_reverse_int;

    variable index : integer := 0;

  begin
    if rising_edge(aclk) then
      if aresetn = '0' then  -- aresetn is active low
        op_sample_first <= '1';
        op_sample       <= 0;
        op_data         <= IP_TABLE_CLEAR;
      elsif m_axis_data_tvalid = '1' and m_axis_data_tready = '1' then
        -- Record output data such that it can be used as input data
        --index := op_sample;
        -- Digit-reverse output sample number, to get actual sample index as outputs are in digit-reversed order
        --index := digit_reverse_int(index, 8);
        --op_data(index).re <= m_axis_data_tdata(33 downto 0);
        --op_data(index).im <= m_axis_data_tdata(73 downto 40);
          op_data(op_sample).re <= m_axis_data_tdata(33 downto 0);
          op_data(op_sample).im <= m_axis_data_tdata(73 downto 40);
          		          --DEBUG
         if (line_wr_2_mem  = LINE_119)  then

         	  --report " *******************";
         	  --report " *******************";
         	  --report " DEBUG/REcord Output";
         	  --report " Line ="             & integer'image(line_wr_2_mem );
              --report " Opsample ="         & integer'image(op_sample);
              --report " Address int ="      & integer'image(address_int );
              --report " Opsample wr 2 mem ="  & integer'image(op_sample_wr_2_mem );
         	  --report " fft real sample = " & integer'image(to_integer(unsigned(op_data(op_sample).re)));
         	  --report " fft imsg sample = " & integer'image(to_integer(unsigned(op_data(op_sample).im)));
         	  --report " *******************";
         	  --report " *******************";
         end if;
        -- Increment output sample counter
        if m_axis_data_tlast = '1' then  -- end of output frame: reset sample counter and increment frame counter
          op_sample <= 0;
          op_frame <= op_frame + 1;
          op_sample_first <= '1';  -- for next output frame
        else
          op_sample_first <= '0';
          op_sample <= op_sample + 1;
        end if;
      end if;
    end if;
  end process record_outputs;

  -----------------------------------------------------------------------
  -- Check outputs
  -----------------------------------------------------------------------

  check_outputs : process
    variable check_ok : boolean := true;
    -- Previous values of data master channel signals
    variable m_data_tvalid_prev : std_logic := '0';
    variable m_data_tready_prev : std_logic := '0';
    variable m_data_tdata_prev  : std_logic_vector(79 downto 0) := (others => '0');
  begin

    -- Check outputs T_STROBE time after rising edge of clock
    wait until rising_edge(aclk);
    wait for T_STROBE;

    -- Do not check the output payload values, as this requires a numerical model
    -- which would make this demonstration testbench unwieldy.
    -- Instead, check the protocol of the data master channel:
    -- check that the payload is valid (not X) when TVALID is high
    -- and check that the payload does not change while TVALID is high until TREADY goes high

    if m_axis_data_tvalid = '1' and aresetn = '1' then
      if is_x(m_axis_data_tdata) then
        report "ERROR: m_axis_data_tdata is invalid when m_axis_data_tvalid is high" severity error;
        check_ok := false;
      end if;

      if m_data_tvalid_prev = '1' and m_data_tready_prev = '0' then  -- payload must be the same as last cycle
        if m_axis_data_tdata /= m_data_tdata_prev then
          report "ERROR: m_axis_data_tdata changed while m_axis_data_tvalid was high and m_axis_data_tready was low" severity error;
          check_ok := false;
        end if;
      end if;

    end if;

    assert check_ok
      report "ERROR: terminating test with failures." severity failure;

    -- Record payload values for checking next clock cycle
    if check_ok then
      m_data_tvalid_prev  := m_axis_data_tvalid;
      m_data_tready_prev  := m_axis_data_tready;
      m_data_tdata_prev   := m_axis_data_tdata;
    end if;

  end process check_outputs;

  -----------------------------------------------------------------------
  -- Assign TDATA / TUSER fields to aliases, for easy simulator waveform viewing
  -----------------------------------------------------------------------

  -- Config slave channel alias signals
  s_axis_config_tdata_fwd_inv    <= s_axis_config_tdata(0);
  s_axis_config_tdata_scale_sch  <= s_axis_config_tdata(8 downto 1);

  -- Data slave channel alias signals
  s_axis_data_tdata_re           <= s_axis_data_tdata(33 downto 0);
  s_axis_data_tdata_im           <= s_axis_data_tdata(73 downto 40);

  -- Data master channel alias signals
  m_axis_data_tdata_re           <= m_axis_data_tdata(33 downto 0);
  m_axis_data_tdata_im           <= m_axis_data_tdata(73 downto 40);

end tb;

